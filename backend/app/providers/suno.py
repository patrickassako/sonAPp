"""
SunoAPI.org Music Provider Implementation.

This provider integrates with SunoAPI.org to generate music.
Based on real API responses as documented in implementation-plan.md.
"""

import httpx
from typing import Dict, List
from app.config import settings
from app.styles import build_prompt


class SunoProvider:
    """
    Music generation provider using SunoAPI.org.
    
    Real API response formats (from documentation):
    
    1. Generate response:
       {"code": 200, "msg": "success", "data": {"taskId": "..."}}
    
    2. Record-info response:
       {
         "code": 200,
         "msg": "success",
         "data": {
           "status": "SUCCESS",  // or "PROCESSING", "FAIL"
           "response": {
             "sunoData": [
               {
                 "audioUrl": "https://...",
                 "streamAudioUrl": "https://...",
                 "imageUrl": "https://...",
                 "duration": 180,
                 "title": "...",
                 "tags": "..."
               }
             ]
           }
         }
       }
    """
    
    def __init__(
        self,
        api_key: str,
        base_url: str = "https://api.sunoapi.org"
    ):
        self.api_key = api_key
        self.base_url = base_url
        # Sync client with generous timeout for slow connections
        self.client = httpx.Client(timeout=httpx.Timeout(60.0, connect=60.0))
    
    def create_track(
        self,
        lyrics: str,
        style_id: str,
        language: str = "fr",
        title: str = ""
    ) -> str:
        """
        Create a track on SunoAPI.org.
        
        Args:
            lyrics: Song lyrics
            style_id: Musical style from registry
            language: "fr" or "en"
            title: Song title (auto-generated if empty)
        
        Returns:
            task_id (str): Provider task ID
        
        Raises:
            Exception: If API call fails
        """
        # Build enriched style description from registry
        prompt_data = build_prompt(style_id, lyrics, language)
        
        # IMPORTANT: In customMode with instrumental=false:
        # - prompt = actual lyrics (what will be sung)
        # - style = style description/genre
        # - title = song title (auto-generated if empty)
        
        payload = {
            "customMode": True,  # Custom mode (user provides lyrics)
            "prompt": lyrics,  # LYRICS (what will be sung)
            "style": prompt_data["style_text"],  # STYLE description from registry
            "title": title or "",  # Auto-generated by Suno if empty
            "instrumental": False,  # We want vocals
            "callBackUrl": "https://example.com/callback",  # Placeholder for MVP (will poll instead)
            "model": "V4_5PLUS"  # Model enum: V4, V4_5PLUS, V5
        }
        
        response = self.client.post(
            f"{self.base_url}/api/v1/generate",
            json=payload,
            headers={
                "Authorization": f"Bearer {self.api_key}",  # Bearer token auth
                "Content-Type": "application/json"
            }
        )
        response.raise_for_status()
        
        data = response.json()
        
        # SunoAPI.org REAL response: {"code":200,"msg":"success","data":{"taskId":"..."}}
        if data.get("code") != 200:
            raise Exception(f"SunoAPI error: {data.get('msg', 'Unknown error')}")
        
        return data["data"]["taskId"]  # Provider task ID (camelCase)
    
    def get_status(self, task_id: str) -> Dict:
        """
        Get status of a generation task.
        
        Args:
            task_id: Provider task ID
        
        Returns:
            {
                "status": "queued|processing|completed|failed",
                "audio_urls": [str] (if completed),
                "metadata": dict (optional),
                "error": str (if failed)
            }
        """
        response = self.client.get(
            f"{self.base_url}/api/v1/generate/record-info",
            params={"taskId": task_id},
            headers={"Authorization": f"Bearer {self.api_key}"}
        )
        response.raise_for_status()
        
        data = response.json()
        
        # Check response code
        if data.get("code") != 200:
            return {
                "status": "failed",
                "error": data.get("msg", "Unknown error")
            }
        
        # Extract nested data
        result_data = data.get("data", {})
        provider_status = result_data.get("status")  # "SUCCESS", "PROCESSING", "FAIL"
        response_obj = result_data.get("response") or {}
        suno_data = response_obj.get("sunoData") or []
        
        # Map provider status to our internal status
        if provider_status == "SUCCESS":
            # SUCCESS but sunoData might be empty or partial (1 track instead of 2)
            if not suno_data:
                # SUCCESS declared but no audio yet - keep processing
                return {"status": "processing", "audio_urls": []}
            
            # Extract audio URLs from all available tracks (usually 2, but accept 1+)
            audio_urls = []
            stream_urls = []
            image_urls = []
            
            for track in suno_data:
                if track.get("audioUrl"):
                    audio_urls.append(track["audioUrl"])
                if track.get("streamAudioUrl"):
                    stream_urls.append(track["streamAudioUrl"])
                if track.get("imageUrl"):
                    image_urls.append(track["imageUrl"])
            
            # Accept 1 or 2 tracks (MVP tolerant UX)
            if audio_urls:
                return {
                    "status": "completed",
                    "audio_urls": audio_urls,
                    "metadata": {
                        "stream_urls": stream_urls,
                        "image_urls": image_urls,
                        "suno_data": suno_data,  # Keep full data for reference
                        "track_count": len(audio_urls)  # 1 or 2
                    }
                }
            else:
                # SUCCESS but no valid audioUrl - keep processing
                return {"status": "processing", "audio_urls": []}
        
        elif provider_status in ("FAIL", "FAILED", "ERROR"):
            error_msg = result_data.get("errorMessage") or "Generation failed"
            return {"status": "failed", "error": error_msg}
        
        elif provider_status == "PROCESSING" or provider_status == "PENDING":
            return {"status": "processing", "audio_urls": []}
        
        else:
            # No status yet or unknown status - still queued
            return {"status": "queued", "audio_urls": []}
    
    def fetch_result(self, task_id: str) -> List[str]:
        """
        Fetch final audio URLs.
        
        Args:
            task_id: Provider task ID
        
        Returns:
            List of audio URLs
        """
        status_data = self.get_status(task_id)
        return status_data.get("audio_urls", [])
    
    def generate_lyrics(self, prompt: str) -> str:
        """
        Generate lyrics using SunoAPI.
        
        Args:
            prompt: Description or topic
            
        Returns:
            task_id: Provider task ID
        """
        payload = {
            "prompt": prompt,
            "callBackUrl": "https://example.com/callback" # Required by API even if polling
        }
        
        response = self.client.post(
            f"{self.base_url}/api/v1/lyrics",
            json=payload,
            headers={
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
        )
        response.raise_for_status()
        data = response.json()
        
        if data.get("code") != 200:
            raise Exception(f"SunoAPI Lyrics Error: {data.get('msg', 'Unknown error')}")
            
        return data["data"]["taskId"]

    def get_lyrics_status(self, task_id: str) -> Dict:
        """
        Get lyrics generation status.
        """
        response = self.client.get(
            f"{self.base_url}/api/v1/lyrics/record-info",
            params={"taskId": task_id},
            headers={"Authorization": f"Bearer {self.api_key}"}
        )
        response.raise_for_status()
        data = response.json()
        
        if data.get("code") != 200:
             return {"status": "failed", "error": data.get("msg", "Unknown error")}
             
        result_data = data.get("data", {})
        status = result_data.get("status")
        
        if status == "SUCCESS":
             resp_obj = result_data.get("response", {})
             candidates = resp_obj.get("data", []) # List of objects {text: "...", title: "..."}
             texts = [c.get("text", "") for c in candidates if c.get("text")]
             
             if not texts:
                 return {"status": "processing"} # Sometimes success but empty?
                 
             return {"status": "completed", "lyrics": texts}
             
        elif status in ("FAIL", "FAILED", "ERROR"):
            return {"status": "failed", "error": result_data.get("errorMessage")}
            
        return {"status": "processing"}

    def close(self):
        """Close HTTP client."""
        self.client.close()


# Singleton instance
_provider_instance = None


def get_suno_provider() -> SunoProvider:
    """Get or create SunoProvider instance."""
    global _provider_instance
    if _provider_instance is None:
        _provider_instance = SunoProvider(
            api_key=settings.SUNO_API_KEY,
            base_url=settings.SUNO_BASE_URL
        )
    return _provider_instance
